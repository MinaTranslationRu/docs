import Page from "@reason/pages/Docs";
export default Page({ title: "Lifecycle of a Payment Technical Guide" });

# Жизненный цикл платежа - технический справочник

Платежи в Mina проходят через несколько этапов, прежде чем они считаются проверенными и завершенными. Этот документ предназначен для того, чтобы познакомиться с тем, что происходит с одним платежом, когда он проходит через кодовую базу. Если вы хотите понять, как платежи работают на макроскопическом уровне, доступен более высокий уровня обзора [жизненного цикла платежа] (/docs/architecture/lifecycle-payment).

Допустим, вы хотите отправить платеж в Mina (при условии, что вами ранее уже был создан счет и вы получили необходимые средства).
Ваш друг даёт вам свой публичный ключ -- это `KEFLx5TOqJNzd6buc+dW3HCjkL57NjnZIaplYJ50DO1uTfogKfwAAAAA`.

Затем вы вызываете следующую команду:

```bash
$ mina client send-payment \
    -amount 10 \
    -receiver KEFLx5TOqJNzd6buc+dW3HCjkL57NjnZIaplYJ50DO1uTfogKfwAAAAA \
    -fee 3 \
    -privkey-path keys/my-wallet
```

Где:

- `amount` это сумма mina, которую вы посылаете
- `receiver` это публичный ключ предполагаемого получателя
- `fee` это комиссия, которая должна быть оплачена сети за обработку транзакции.
- `privkey-path` это путь к файлу с закрытым ключом для вашего аккаунта.

## Клиент Mina 

Файл [client.ml](https://github.com/MinaProtocol/mina/tree/master/src/app/cli/src/client.ml) определяет парсер команд CLI для подкоманд `mina client`.
Мы часто используем стандартные библиотеки [Jane Street](https://github.com/janestreet).
В частности, очень часто используются [Core](https://opensource.janestreet.com/core/) (общие структуры данных) и [Async](https://opensource.janestreet.com/async/) (асинхронное программирование с использованием составного типа `Deferred.t`).
Поверх большинства файлов вы увидите какой-либо вариант `open Core` и `open Async`.
В [client.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/client.ml) мы тоже это видим. `Async` затеняет тип `Command` и позволяет нам декларативно отразить детали каждой команды.
Если вы прокрутите вниз [client.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/client.ml), вы увидите, что мы регистрируем команду `send-payment` в функции `send_payment`.
Здесь мы описываем флаги, от которых зависит это действие: `receiver` [публичного ключа](#public-key), комиссии, суммы и пути к вашему [приватному ключу](#private-key). Эти типы параметров флага определены в [daemon_rpcs.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/daemon_rpcs.ml).
В теле `send_payment` мы создаем платеж и пересылаем его [daemon](#daemon).

## Платеж

В [payment.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/payment.mli) вы увидите пару важных вещей. (1) мы разбиваем платежи на [платежную нагрузку](#payment-payload) (часть, которая должна быть [подписана](#signature)) и остальное. И (2) вы видите тип, который, хоть и определяется в странной манере, но является общим шаблоном в нашей кодовой базе.

См. более подробную информацию:

- [Параметризованные отчеты](/docs/developers/style-guide/#parameterized-records)
- [Ppx deriving](/docs/developers/style-guide/#ppx_deriving)
- [Stable.V1](/docs/developers/style-guide/#stable-v1)
- [Property based тесты](/docs/developers/style-guide/#quickcheck-gen)
- [Typesafe Invariants](/docs/developers/style-guide/#typesafe-invariants)
- [Unit Тесты](/docs/developers/style-guide/#unit-tests)

Давайте разберемся с платежной нагрузкой:

## Платежная нагрузка

Ознакомьтесь с разделом [payment_payload.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/payment_payload.mli). Напомним, что платежная нагрузка является частью платежа, который отправитель подпишет своим приватным ключом. Мы видим, что нагрузка строится из [публичного ключа](#public-key) получателя, [суммы](#currency), [комиссии](#currency), и [однократно используемого числа](#account-nonce). Опять же, полезная нагрузка содержит SNARK, поэтому она имеет `type var`, и другие важные функции со SNARK (в будущем RFC мы поместим это в пользовательскую [ppx_deriving](#ppx-deriving).


## Подписи

(TODO: @ihm can you correct any details I mess up here)

Мы используем [подписи Шнорра](https://en.wikipedia.org/wiki/Schnorr_signature). [Подпись Шнорра](https://en.wikipedia.org/wiki/Schnorr_signature) является элементом в [группе](https://en.wikipedia.org/wiki/Group_(mathematics). Наша группа - это точка на [эллиптической кривой](https://en.wikipedia.org/wiki/Elliptic_curve). Так что же такое подпись? Откройте [библиотеки подписи checked.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/checked.ml) и прокрутите до `module Signature` внутри `module type S`. Это ненулевая точка на кривой, также известная как пара двух значений `curve_scalar`. Для подписи мы даем [закрытый ключ](#private-key) и сообщение. Проверить подпись в сообщении можно с помощью [открытого ключа](#public-key).


Это первый раз, когда мы видим тяжело функторированный код, поэтому смотрите [функторы](/docs/developers/style-guide/#functors), если запутаетесь. Это также первый раз, когда мы видим пользовательскую схему SNARK. Для более подробной информации зайдите в раздел [пользовательская схема SNARK"](/docs/developers/style-guide/#snark-checked). 

## Приватный ключ

В разделе [private_key.ml] (https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/private_key.ml) мы видим закрытый ключ `Tick.Inner_curve.Scalar.t` или скаляр на эллиптической кривой. Давайте разберем его точнее: Так как мы полагаемся на [рекурсивные zkSNARK](https://eprint.iacr.org/2014/595), то на самом деле у нас есть две эллиптические кривые `Tick` и `Tock`. Большая часть нашей логики происходит внутри `Tick` (TODO: @ihm expand on this). [Подписи Шнорра](#signature) требуют, чтобы мы использовали скаляры для нашего приватного ключа. 

## Открытый ключ

Открытый ключ, соответствующий [закрытому ключу] (#private-key) `p` - это просто $one^p$, или, другими словами, $one*one*one ....{p times}... one$. Мы можем увидеть это в [public_key.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/public_key.ml). Помните, что элементы группы являются ненулевыми точками кривой, поэтому мы также `include Non_zero_curve_point`.

Открытые ключи также можно сжимать -- см. [public_key.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/public_key.mli). Точка на эллиптической кривой может быть однозначно представлена одним элементом скалярного поля и boolean. Это представление мы используем в [платежной нагрузке](#payment-payload), так как оно более эффективно внутри схем SNARK.

## Валюта

В [currency.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/currency/currency.mli) мы определяем [номинальные типы](https://en.wikipedia.org/wiki/Nominal_type_system) комиссии, сумму и баланс, которые корректно обрабатывают overflow и underflow. На данный момент все поддерживается 64-битными беззнаковыми числами. Обратите внимание, что мы снова включаем операции схемы SNARK с [проверкой](#snark-checked) подмодулей внутри каждого из типов.

## Аккаунт

Платежи проводятся успешно только в том случае, если счет отправителя обладает определенными свойствами (и при этом баланс получателя не переполняется).

Согласно[account.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/account.ml), аккаунт - это запись с [публичным ключом](#public-key) (владельца учетной записи), [балансом](#currency), [однократно используемым числом nonce](#account-nonce), и [хэшем цепи поступлений](#receipt-chainh-hash).

Платеж действителен, если:

1. Подпись соответствует w.r.t. открытого ключа отправителя.
2. Отправитель имеет достаточно средств, чтобы произвести выплату комиссионного вознаграждения и суммы.
3. У получателя достаточно места для суммы s.t. переполнения не будет.
4. Показатель [nonce аккаунта](#account-nonce) совпадает с показателем nonce внутри платежа.

When we apply a payment we also cons it onto the [receipt chain](#receipt-chain-hash), and increment the account nonce.

Fees are handled out-of-band see the [fee excess system](#fee-excess).

This is encoded inside the SNARK in [transaction_snark.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/transaction_snark/transaction_snark.ml), specifically the `apply_tagged_transaction` function, although you'll need to look at how the bool flags are set in the `is_normal` case.

It's captured outside the SNARK here: (TODO: where is this? Staged_ledger somewhere?)

### Account Nonce

The [account_nonce.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_numbers/account_nonce.mli) is just a [nominal type](https://en.wikipedia.org/wiki/Nominal_type_system) around a natural number. This is used for protection against double-application of payments.
The account nonce is incremented in the sender's the account whenever a payment is applied.

### Receipt Chain Hash

The [receipt.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/receipt.mli) chain hash is the top hash of a [merkle list](#merkle-list) of payment payloads. This is used to prove that you actually made a payment to someone. Since Mina doesn't keep payment history, this is how you can prove to someone that your payment went through.

How does it work?

A merkle list is like a [merkle tree](https://en.wikipedia.org/wiki/Merkle_tree) but with one branch. As long as you keep your merkle list hashes, you can prove that any individual piece of data was part of the list if you know for sure what the top hash is.

If it's important to prove your payment went through, you ask the receiver to start recording receipt chain hashs, and hand your payment payload over to the receiver. He can then check the top hash of their receipt chain to see if it includes your payload.

## Take a break!

We've fully described all the components of a `Payment.t`. Congrats on making it this far!

After a break, we'll be ready to dive into the daemon code.

## Daemon

The mina daemon is defined inline in [mina.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina.ml). Search for the `daemon` function to see the CLI flags we use there. The daemon is optionally auto-started by the client if it doesn't already exist. We get configuration from a JSON configuration file (try first from `-f`, then from `$XDG_CONFIG_DIR/mina/daemon.json`, then from `/etc/mina/daemon.json`). We do a lot of setup here which leads up to invoking `Mina_main.Mina.Make` and then `Run`ing it. The details of those are described below.

When we have the `Run` module, we can make an instance of the mina daemon at the value level, and set up any background processes and services.

## Main

By the time you're reading this, hopefully we've tamed the beast that is [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml). Here we wire the system together at the module level. What does this mean? We instantiate all the functors for the different subcomponents of the daemon. Eventually we create something that conforms to `Main_intf` (in this same file).

### Run functor

At the bottom of [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml), we define a `Run` functor that finally has the other side of the `rpc` call that the client makes to `send_payment`. Run contains the server-side implementations of all the RPC calls the client makes. It also is responsible for logic of setting up any RPC/webservers servers and background processes.

Let's assume we have an instance of `Run.t` already created, and we'll circle back later.

### Client_rpc

In [daemon_rpcs.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/daemon_rpcs/daemon_rpcs.ml), we define the concrete RPC calls that the client uses to communicate to the daemon. We use [Async](https://opensource.janestreet.com/async/)'s RPC library for this. `Send_payments` defined the RPC call we use to send the payment: the query type is the input -- the payments we want to send -- and the response is the output -- in this case `unit`, because we don't get any meaningful feedback other than "the payment has been enqueued" on success.

### Schedule payment into Transaction pool

Back in [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml), we invoke `send_payment` in [Run](#run), that delegates to `schedule_payment` -- here we enqueue the payment into the [Transaction Pool](#transaction-pool).

## Mina_lib

To create a `Run` instance we'll need to go to [mina_lib.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_lib/mina_lib.ml) where we wire all subsystems together at the value level. This is in contrast to [mina_main.ml](#main) where we wire all the subsystems together at the module level.

It's here where we can trace the path of the payment from the transaction pool forwards. Let's sketch that out before diving deeper into each of the subsystems:

1. The [transaction pool](#transaction-pool) broadcasts diffs from the transaction pool through to the [network](#network)
2. The [proposer](#proposer) reads payments from the transaction pool when it's time to make a transition from one blockchain state to another, those payments are part of a diff to update a [staged-ledger](#staged-ledger) which is committed to inside the new blockchain state. [External transitions](#external-transition) are emitted.
3. The [network](#network) and the [proposer](#proposer) feed [external transitions](#external-transition) containing information on how to update a [staged-ledger](#staged-ledger) with the new payment buffered to the [ledger builder controller](#ledger-builder-controller)
4. The [ledger builder controller](#ledger-builder-controller) figures out where this [external transition](#external-transition) fits in it's tree of possible forks. If this happens to extend our "best" path (the state upon which we will propose later) then we do an expensive materialization step to create a [tip](#tip) holding the new [staged ledger](#staged-ledger) and emit this strongest tip over the [network](#network). Healthy clients only forward tips they locally think are the strongest.

## Transaction Pool

Open up [transaction_pool.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/transaction_poll/transaction_pool.ml)... TODO

## Network

TODO

## Proposer

TODO

## External Transition

TODO

## Ledger-builder-controller

TODO

## Staged-ledger

A staged ledger can be regarded as a "Pending accounts database" that has transactions(payments, coinbase, and proof-fees) applied for which there are no snarks available yet.
A staged ledger consists of the accounts state (what we currently call ledger) and a data structure called [parallel_scan.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/parallel_scan/parallel_scan.ml). It keeps track of all the transactions that need to be snarked (grep for `Available_job.t`) to produce a single transaction snark that certifies a set of transactions. This is exposed as Aux in the staged ledger.
Parallel scan is a tree like structure that stores statements needed to be proved. A statement can be of applying a single transaction `Base` or of composing other statements `Merge`. Snarking of these statements is delegated to snark-workers. The snark workers submit snarks for the corresponding statements which are used by the proposer to update the parallel scan state.

When the propser wins a block, the payments read from the transaction pool are sent to the staged ledger to create a diff `Staged_ledger_diff`.
A diff consists of

1. Payments included in the block
2. A list of proofs that prove some of the transactions (payments, coinbase, and proof-fees) from previous blocks
3. Coinbase

There are two primary operations in staged ledger.

1. Creating a diff :
   To include a payment from the transaction pool, the proposer needs to include snarks generated by its own snark-workers (or buy it from someone) which certifies some of the transactions added in previous blocks. The number of snarks needs to be twice the number of transactions being included in the block (an invariant of the aux data structure). These proofs are included in the diff along with the payments and coinbase.
   The diff is then included in the external transition and broadcasted to the network.

2. Applying a diff: Diffs from the node itself (Internal transitions) or from the network (External transitions) are then used to update the staged ledger by applying the payments to the ledger and updating the parallel scan state with the proofs. Applying a diff may produce a proof for a sequence of transactions that were included in the previous blocks.

## Ledger

TODO

import Page from "@reason/pages/Docs";
export default Page({ title: "Style Guide" });

# Руководство по стилю

## Ocaml

[ocaml]: #ocaml

### Общее

[ocaml-general]: #ocaml-general

Наши руководящие принципы по стилю являются продолжением пары существующих рекомендаций по стилю. Первый из них - ocamlformat, он действует как источник истины для большинства наших стилей кодирования. На самом деле, ocamlformat является блокиратором на CI, поэтому ваш код должен быть сформирован в соответствии с его рекомендациями для слияния с master. Тем не менее, ocamlformat не обрабатывает все важные случаи стиля. Он лишь определяет и реализует то, как код должен быть разделен на части и какие должен иметь отступы. Для всего, на что не распространяется ocamlformat, следует ссылаться на [руководство по Jane Street](https://opensource.janestreet.com/standards/). Это руководство по стилю предназначено для расширения стилистики janestreet, с более пристальным вниманием к деталям, относящимся к нескольким специфическим конструкциям, которые мы регулярно используем в нашей кодовой базе.

### Mli-файлы

[ocaml-mli]: #ocaml-mli

Файл `*.mli` не должен включаться в файл `*.ml`, если интерфейс автоматически получаемого файла `*.ml` отличается. Многие файлы `*.ml` в нашей кодовой базе состоят только из сигнатур и функтора. Применительно к этим файлам, переопределение файла `*.mli` не имеет смысла, так как в нём нет новой или ограниченной информации. Если файл `*.ml` содержит реализации в корневой структуре, то, скорее всего, следует создать файл `*.mli`.

### Модули

[ocaml-modules]: #ocaml-modules

#### Предпочитаемые стандартизированные сокращения

Имена `t`, `T` и `S` - это обычные короткие имена, используемые в модулях для обозначения отдельных объектов.

Имя `t` используется для обозначения корневого типа модуля. Например, если существует модуль `Account`, который содержит типы и значения, связанные с учётными записями, то `Account.t` - это тип учётной записи. Имя `t` также может быть использовано в качестве значения, если существует только одно значение корневого типа модуля. Например, если вы хотите иметь один глобальный регистратор в модуле `Logger`, то тип `Logger.t` может быть типом регистратора, а значение `Logger.t` может быть значением глобального регистратора типа `Logger.t`.

Имя модуля `T` используется для инкапсуляции типа корня и основных определений относительно типа корня модуля. Это обычная практика, используемая, когда вы хотите инстанцировать некоторые функции для типа корня модуля, с появлением экземпляров в самом модуле. В качестве примера, принято вызывать functor `Comparable.Make` для получения различных вспомогательных значений/модулей от сопоставимого типа. В этом случае, если бы у нас опять был модуль `Account`, и мы хотели бы получить сигнатуру `Comparable.S`, то мы бы определили модуль `T` в `Account`, который определяет тип корня `t` и необходимые функции для аргумента `Comparable.Make` functor (в данном случае, `compare`). С помощью этого модуля `T`, мы можем затем включить `T` и `Comparable.Make (T)` в модуль `Account` для внесения всех связанных значений/модулей для типа `Account.t`. Вот полный пример этого:

```
module Account = struct
  module T = struct
    type t = ... [@@deriving compare]
  end

  include T
  include Comparable.Make (T)
end
```

Имя типа модуля `S` используется для определения корневой подписи модуля. Чаще всего это используется, когда у вас есть модуль, который содержит functor. В этом случае мы обычно вызываем functor `Make`, и объявляем, что functor возвращает тип `S`, помещая оба этих значения в один модуль. Оглядываясь на наш предыдущий пример, модуль `Comparable` для `Core_kernel` следует этому шаблону: `Comparable.Make` - это functor, который возвращает `Comparable.S`. 

#### Предпочтение одному типу на один модуль

[ocaml-modules-singleton-types]: #ocaml-modules-singleton-types

Как правило, каждый модуль должен быть сведен к одному типу. Этот шаблон помогает выделить проблемы и, в свою очередь, позволяет сократить имена значений, так как они расположены по контексту. Возьмем, к примеру, модуль `Merkle_tree`. Этому модулю понадобится тип `Merkle_tree.t`, который представляет собой все дерево хэшей (или его ноду). Дерево `Merkle_tree` также будет хотеть иметь тип `path`. Предпочтительно поместить этот тип `path` в собственный вложенный модуль (`Merkle_tree.Path.t` вместо `Merkle_tree.path`). Чтобы понять, почему это предпочтительнее, представьте, что мы поместили путь в `Merkle_tree.path`. Теперь `Merkle_tree` содержит значения (функции), которые относятся не только к самому типу дерева хэшей, но и к пути дерева. Для наглядности, было бы естественно начинать все имена значений, связанных с путём, с `path_` (`path_map`, `path_length` и т.д....). Изолируя `Path` в свой собственный модуль, мы можем сократить эти имена, сохраняя при этом понятным контекст значений. Дополнительно, если в будущем мы решим это сделать, мы можем инкапсулировать детали реализации `Path`, применив к нему ограничительную сигнатуру, что сделает разделение проблем более понятным с помощью принудительной реализации компилятора.

#### Никакого партизанского патчинга

[ocaml-modules-monkeypatching]: #ocaml-modules-monkeypatching

Партизанский (обезьяний) патчинг модулей в нашей кодовой базе запрещен. Партизанский патчинг определяется как акт взятия существующего модуля и переопределения его с расширенными или измененными значениями. Другими словами, это может быть всё, что угодно по форме.

```
module A = struct
  module M = struct
    let x = ...
  end
end

module M = struct
  include A.M
  let y = ...
  (* or `let x = ...` *)
end
```

Обезьяний патчинг иногда может быть самым простым способом получения кода для компиляции, но в целом он создает путаницу и/или технический долг в кодовой базе. У вас должны быть веские причины, чтобы прибегать к партизанскому патчингу.

#### Функтор Равенства Подписей

[ocaml-modules-functor-patterns]: #ocaml-modules-functor-patterns

Сигнатура `с` отчетами для подписей модулей, генерируемых функторами, должна быть по возможности ограничена формой `S с модулем M1 = M2`. Равенства замены `:=` должны быть ограничены отчетами `include`, когда части подписи нуждаются в ограничении (например, когда вложенный модуль в подписи уже определен в текущем диапазоне структуры). Форма `S с типом t = ...` также не является предпочтительной, так как она плохо масштабируется по мере увеличения количества общих зависимостей между подписями, участвующих в функторе. Обратите внимание, что это увеличивает значение для правила руководства по стилю janestreet "Предпочтение стандартной подписи включает в себя рукописные интерфейсы". 

#### Арность Функтора

[ocaml-modules-functor-arity]: #ocaml-modules-functor-arity

Функтор может иметь максимальную арность 3 (арность - количество аргументов; в данном случае количество вложенных функторов - functors returning functors). Если функтор требует в качестве аргументов более 3 модулей, то все необходимые модули должны быть вложены в один модуль. Стандартным шаблоном для этого является определение сигнатуры `Inputs_intf` для вашего функтора, которая, в свою очередь, будет определять аргументы модуля к данному функциональному объекту. Смотрите ниже простой пример.

```
module type Inputs_intf = sig
  module A : A.S
  module B : B.S
  module C : C.S
  module D : D.S
end

module type S = sig
  include Inputs_intf

  (* ... *)
end

module Make (Inputs : Inputs_intf)
  : S
    with module A = Inputs.A
     and module B = Inputs.B
     and module C = Inputs.C
     and module D = Inputs.D =
struct
  open Inputs

  (* ... *)
end
```

# Идиосинкразия кода 

Мы используем специфический стиль OCaml. Вот некоторые важные моменты.

## Параметрические записи

```ocaml
type ('payload, 'pk, 'signature) t_ =
  {payload: 'payload; sender: 'pk; signature: 'signature}
[@@deriving eq, sexp, hash]

type t = (Payload.t, Public_key.t, Signature.t) t_
[@@deriving eq, sexp, hash]

(* ... *)

type var = (Payload.var, Public_key.var, Signature.var) t_
```

Мы определяем базовый тип `t_` с переменными типа для всех типов полей записи. Затем мы определяем запись, используя эти переменные типа. Наконец, мы инстанцируем запись с `типом t`, то есть тип OCaml. Кроме того, `тип var` - это тип этого значения в контуре SNARK. Об этом мы поговорим позже. Всякий раз, когда мы хотим, чтобы что-либо было программируемым из контура SNARK, мы определяем это таким образом, чтобы мы могли повторно использовать определение записи для обоих типов.

Некоторые говорят о переходе на типы объектов OCaml, чтобы сделать такие вещи, так что нам не нужно иметь дело с позиционными аргументами. Возможно, я (@bkase) когда-нибудь напишу RFC для этого.

### Ppx_deriving

```ocaml
type t = int [@@deriving sexp, eq]
```

Это первый раз, когда мы видим макрос. Здесь мы используем `sexp` из [ppx_jane](https://github.com/janestreet/ppx_jane) и `eq` из [ppx_deriving](https://github.com/ocaml-ppx/ppx_deriving).

### Stable.V1

```ocaml
module Stable : sig
  module V1 : sig
    type t = (* ... *)
    [@@deriving bin_io, (*...*)]
  end
end
```

Всякий раз, когда тип может быть сериализован, для нас важно поддерживать обратную совместимость после релиза stable. В идеале, мы бы не определяли `bin_io` ни на одном типе за пределами `Stable.V1`. Когда мы изменяем структуру типа данных, мы создаем `V2` под `Stable`.

### Property-based тестирование

[Core](https://opensource.janestreet.com/core/) имеет реализацию [QuickCheck](https://blog.janestreet.com/quickcheck-for-core/), которую мы используем всякий раз, когда это возможно в юнит-тестах. Вот пример подписи для платежей `Quickcheck.Generator.t`.

```ocaml
(* Generate a single payment between
 * $a, b \in keys$
 * for fee $\in [0,max_fee]$
 * and an amount $\in [1,max_amount]$
 *)

val gen :
     keys:Signature_keypair.t array
  -> max_amount:int
  -> max_fee:int
  -> t Quickcheck.Generator.t
```

<a name="typesafe-invariants"></a>
### Инварианты Typesafe (помощь с названиями)

Часто в Mina нам приходится проводить очень важные проверки определенных фрагментов данных.
Например, нам нужно подтвердить, что подпись, которую мы получаем по сети, действительно соответствует директиве пользователя.
Такие проверки могут быть дорогостоящими, поэтому мы хотим сделать их только один раз, но мы хотим помнить о том, что мы их сделали.

```ocaml
(* inside user_command.mli *)

module With_valid_signature : sig
  type nonrec t = private t [@@deriving sexp, eq]

  (*...*)
end

val check : t -> With_valid_signature.t option
```

Здесь мы задаём `With_valid_signature` (будет употребляться как `User_command.With_valid_signature.t`), используя `type nonrec t = private t` для разрешения апкастинга до `User_command.t`, и предотвращая даункастинг. С помощью  _only_ можно преобразовать `User_command.t` в `User_command.t`. А с помощью `_valid_signature.t` можно контролировать это (`check`). Теперь компилятор поймает все наши ошибки.

### Юнит тесты

Для юнит-тестирования мы используем [ppx_inline_test](https://github.com/janestreet/ppx_inline_test). Конечно, всякий раз, когда это возможно, мы комбинируем это с `QuickCheck. 

```ocaml
let%test_unit =
  Quickcheck.test ~sexp:[%sexp_of: Int.t] Int.quickcheck_generator
    ~f:(fun x -> assert (Int.equal (f_inv (f x)) x))
```

### Функторы

Мы находимся в процессе перехода на использование модульных сигнатурных равнозначностей -- см. [раздел выше](#functor-signature-equalities) и [rfc for rationale](https://github.com/MinaProtocol/mina/blob/master/rfcs/0004-style-guidelines.md), но у нас еще много кода, использующего подстановку типов (`with type foo := bar`). 

В [signature_lib/checked.ml](https://github.com/MinaProtocol/mina/blob/master/src/lib/signature_lib/checked.ml) у нас есть пример определения с использованием подстановок типов. Сначала мы определяем результирующий тип модуля функтора, сохраняя все типы, которые мы будем абстрактно изменять. 

```ocaml
module type S = sig
  type boolean_var
  type curve
  type curve_var
  (*...*)
end
```

Затем мы определяем функтор:

```ocaml
module Schnorr
  (Impl : Snark_intf.S)
  (Curve : sig (*...*) end)
  (Message : Message_intf
    with type boolean_var := Impl.Boolean.var
    (*...*))
: S with type boolean_var := Impl.Boolean.var
     and type curve := Curve.t
     and type curve_var := Curve.var
     (*...*)
= struct
  (* here we implement the signature described in S *)
end
```

### Пользовательская логика схемы SNARK

Также мы впервые видим логику пользовательской схемы SNARK. Шаблон, который мы используем - это проверка всех операций, которые вы захотите запустить внутри SNARK под субмодулем `module Checked`.

Например, внутри [sgn.mli](https://github.com/MinaProtocol/mina/blob/master/src/lib/sgn/sgn.mli) мы видим:

```ocaml
(* ... *)
val negate : t -> t

module Checked : sig
  val negate : var -> var
end
```

`negate` это версия функции, которая запущена в OCaml, а `Checked.negate` запускается внутри контура SNARK.
